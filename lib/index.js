// Generated by CoffeeScript 1.10.0
(function() {
  var Coffee, async, coffee, join,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  join = require("path").join;

  coffee = require('coffee-script');

  async = require('async');

  Coffee = (function() {
    function Coffee(options) {
      var Middleware, middleware;
      Middleware = (function() {
        function Middleware(options1) {
          var i, len, method, ref;
          this.options = options1;
          this.convert = bind(this.convert, this);
          this.output = bind(this.output, this);
          this.filter = bind(this.filter, this);
          this.regex = coffee.FILE_EXTENSIONS.join("$|");
          this.regex = new RegExp(this.regex.replace(/\./g, "\\.") + "$", "g");
          if (typeof this.options !== "object") {
            this.options = {};
          }
          ref = ["filter", "output"];
          for (i = 0, len = ref.length; i < len; i++) {
            method = ref[i];
            if (this.options[method] && typeof this.options[method] !== "function") {
              delete this.options[method];
              console.error("invalid option." + method + " method");
            }
          }
        }

        Middleware.prototype.filter = function(filepath) {
          return this.regex.test(filepath);
        };

        Middleware.prototype.output = function(filepath) {
          return filepath.replace(this.regex, '.js');
        };

        Middleware.prototype.convert = function(options, files, source, done) {
          var contents, data, err, error, message, outputFile, outputMap;
          data = files[source];
          if (!data || !data.contents) {
            message = 'data does not exist';
            return done(new Error(message));
          }
          try {
            contents = coffee.compile(data.contents.toString(), options);
            outputFile = (options.output || this.output)(source);
            if (options.sourceMap) {
              outputMap = (options.output || this.output)(source) + '.map';
            }
            if (options.sourceMap) {
              files[outputFile] = {
                contents: new Buffer(contents.js + '\n//# sourceMappingURL=' + outputMap)
              };
              files[outputMap] = {
                contents: new Buffer(contents.v3SourceMap)
              };
            } else {
              files[outputFile] = {
                contents: new Buffer(contents)
              };
            }
            return done(null);
          } catch (error) {
            err = error;
            return done(err);
          }
        };

        Middleware.prototype.plugin = function(files, metalsmith, done) {
          var err, error, paths;
          try {
            paths = Object.keys(files).filter(this.options.filter || this.filter);
          } catch (error) {
            err = error;
            return done(err);
          }
          return async.each(paths, this.convert.bind(null, this.options, files), (function(_this) {
            return function(err) {
              if (err) {
                return done(err);
              }
              if (!_this.options.preserveSources) {
                paths.map(function(file) {
                  return delete files[file];
                });
              }
              return done(null);
            };
          })(this));
        };

        return Middleware;

      })();
      middleware = new Middleware(options);
      return middleware.plugin.bind(middleware);
    }

    return Coffee;

  })();

  module.exports = Coffee;

}).call(this);
